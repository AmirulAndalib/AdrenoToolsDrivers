name: Poll External Repo Actions

on:
  schedule:
    - cron: '*/5 * * * *'  # Runs every 5 minutes; adjust as needed (GitHub cron format)
  workflow_dispatch:  # Allows manual trigger for testing

jobs:
  poll-and-notify:
    runs-on: ubuntu-latest
    steps:
      - name: Poll GitHub API for workflow runs
        id: poll
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Optional; not needed for public repos
        run: |
          # Target repo details
          REPO_OWNER="FEX-Emu"
          REPO_NAME="FEX"
          
          # Export to GitHub env for later steps
          echo "REPO_OWNER=$REPO_OWNER" >> $GITHUB_ENV
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          
          # Fetch repo details for icon
          REPO_INFO=$(curl -s -f "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}")
          REPO_ICON=$(echo "$REPO_INFO" | jq -r '.owner.avatar_url')
          echo "repo_icon=$REPO_ICON" >> $GITHUB_OUTPUT
          
          # Fetch recent runs
          API_URL="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?per_page=1&status=completed"  # Just the latest for notify
          RUNS=$(curl -s -f "$API_URL")
          
          # Check for API errors (e.g., 404 Not Found)
          if echo "$RUNS" | jq -e '.message? == "Not Found"' >/dev/null; then
            echo "Error: Repo ${REPO_OWNER}/${REPO_NAME} not found."
            exit 1
          fi
          
          # Get count and handle empty
          RUNS_COUNT=$(echo "$RUNS" | jq '.workflow_runs | length')
          if [ "$RUNS_COUNT" -gt 0 ]; then
            # Extract latest run details for embed (sanitize commit_msg for outputs)
            RUN_NAME=$(echo "$RUNS" | jq -r '.workflow_runs[0].name')
            RUN_STATUS=$(echo "$RUNS" | jq -r '.workflow_runs[0].conclusion')
            RUN_STATUS_UPPER=$(echo "$RUN_STATUS" | tr '[:lower:]' '[:upper:]')
            RUN_ACTOR=$(echo "$RUNS" | jq -r '.workflow_runs[0].actor.login')
            RUN_ACTOR_ID=$(echo "$RUNS" | jq -r '.workflow_runs[0].actor.id')
            RUN_TIME=$(echo "$RUNS" | jq -r '.workflow_runs[0].created_at')
            RUN_URL=$(echo "$RUNS" | jq -r '.workflow_runs[0].html_url')
            RUN_ID=$(echo "$RUNS" | jq -r '.workflow_runs[0].id')
            COMMIT_MSG_RAW=$(echo "$RUNS" | jq -r '.workflow_runs[0].head_commit.message // "No commit message"')
            COMMIT_MSG=$(echo "$COMMIT_MSG_RAW" | tr '\n' ' ' | sed 's/"/\\"/g' | cut -c1-200)  # Sanitize: remove newlines, escape quotes, truncate
            COMMIT_SHA=$(echo "$RUNS" | jq -r '.workflow_runs[0].head_commit.id // "No SHA"' | cut -c1-7)  # Short SHA
            COMMIT_AUTHOR=$(echo "$RUNS" | jq -r '.workflow_runs[0].head_commit.author.name // "Unknown"')
            
            # Set outputs (now sanitized)
            echo "run_name=$RUN_NAME" >> $GITHUB_OUTPUT
            echo "run_status=$RUN_STATUS_UPPER" >> $GITHUB_OUTPUT
            echo "run_actor=$RUN_ACTOR" >> $GITHUB_OUTPUT
            echo "run_actor_id=$RUN_ACTOR_ID" >> $GITHUB_OUTPUT
            echo "run_time=$RUN_TIME" >> $GITHUB_OUTPUT
            echo "run_url=$RUN_URL" >> $GITHUB_OUTPUT
            echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
            echo "commit_msg=$COMMIT_MSG" >> $GITHUB_OUTPUT
            echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
            echo "commit_author=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
            echo "New run detected: $RUN_NAME ($RUN_STATUS) by $RUN_ACTOR."
          else
            echo "run_id=none" >> $GITHUB_OUTPUT
            echo "No completed runs foundâ€”skipping notify."
          fi

      - name: Send Rich Embed to Discord
        if: steps.poll.outputs.run_id != 'none'
        env:
          WEBHOOK_URL: ${{ secrets.FEXEMU_WEBHOOK }}
        run: |
          # Determine color
          COLOR=3447003  # Default blue
          if [ "${{ steps.poll.outputs.run_status }}" = "SUCCESS" ]; then
            COLOR=65280  # Green
          elif [ "${{ steps.poll.outputs.run_status }}" = "FAILURE" ]; then
            COLOR=16711680  # Red
          fi
          
          # Build embed with jq for proper escaping
          EMBED_JSON=$(jq -n \
            --arg username "GitHub Actions Bot" \
            --argjson color "$COLOR" \
            --arg title "${{ steps.poll.outputs.run_name }}" \
            --arg status "${{ steps.poll.outputs.run_status }}" \
            --arg actor "${{ steps.poll.outputs.run_actor }}" \
            --arg time "${{ steps.poll.outputs.run_time }}" \
            --arg runid "${{ steps.poll.outputs.run_id }}" \
            --arg sha "${{ steps.poll.outputs.commit_sha }}" \
            --arg author "${{ steps.poll.outputs.commit_author }}" \
            --arg msg "${{ steps.poll.outputs.commit_msg }}" \
            --arg url "${{ steps.poll.outputs.run_url }}" \
            --arg repo_icon "${{ steps.poll.outputs.repo_icon }}" \
            --arg actor_id "${{ steps.poll.outputs.run_actor_id }}" \
            '{
              username: $username,
              embeds: [{
                author: {
                  name: "FEX-Emu/FEX",
                  icon_url: $repo_icon
                },
                title: $title,
                description: "**Status:** \($status)\n**Triggered by:** \($actor)\n**Time:** \($time)\n**Run ID:** \($runid)\n**Commit:** `\($sha)` by \($author)\n**Message:** \($msg)",
                url: $url,
                color: $color,
                footer: {
                  text: "Check the Actions tab for full logs"
                },
                thumbnail: {
                  url: "https://avatars.githubusercontent.com/u/\($actor_id)?v=4"
                }
              }]
            }')
          
          # Send via curl
          curl -H "Content-Type: application/json" \
               -X POST \
               -d "$EMBED_JSON" \
               "$WEBHOOK_URL"
          
          echo "Embed sent successfully!"
