name: Poll External Repo Actions

on:
  schedule:
    - cron: '*/5 * * * *'  # Runs every 5 minutes; adjust as needed (GitHub cron format)
  workflow_dispatch:  # Allows manual trigger for testing

jobs:
  poll-and-notify:
    runs-on: ubuntu-latest
    steps:
      - name: Poll GitHub API for workflow runs
        id: poll
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Optional; not needed for public repos
        run: |
          # Target repo details
          REPO_OWNER="FEX-Emu"
          REPO_NAME="FEX"
          BRANCH="main"  # Assume main; adjust if needed
          
          # Export to GitHub env for later steps
          echo "REPO_OWNER=$REPO_OWNER" >> $GITHUB_ENV
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          
          # Fetch recent commits for second message
          RECENT_COMMITS=$(curl -s -f "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/commits?per_page=2&sha=${BRANCH}")
          NUM_COMMITS=$(echo "$RECENT_COMMITS" | jq '. | length')
          if [ "$NUM_COMMITS" -gt 0 ]; then
            COMMIT1_SHA=$(echo "$RECENT_COMMITS" | jq -r '.[0].sha | .[:7]')
            COMMIT1_TITLE=$(echo "$RECENT_COMMITS" | jq -r '.[0].commit.message | split("\n")[0]')
            COMMIT1_AUTHOR=$(echo "$RECENT_COMMITS" | jq -r '.[0].commit.author.name')
            COMMIT1_URL=$(echo "$RECENT_COMMITS" | jq -r '.[0].html_url')
            echo "commit1_line=[${COMMIT1_SHA}](${COMMIT1_URL}) ${COMMIT1_TITLE} - ${COMMIT1_AUTHOR}" >> $GITHUB_OUTPUT
          fi
          if [ "$NUM_COMMITS" -gt 1 ]; then
            COMMIT2_SHA=$(echo "$RECENT_COMMITS" | jq -r '.[1].sha | .[:7]')
            COMMIT2_TITLE=$(echo "$RECENT_COMMITS" | jq -r '.[1].commit.message | split("\n")[0]')
            COMMIT2_AUTHOR=$(echo "$RECENT_COMMITS" | jq -r '.[1].commit.author.name')
            COMMIT2_URL=$(echo "$RECENT_COMMITS" | jq -r '.[1].html_url')
            echo "commit2_line=[${COMMIT2_SHA}](${COMMIT2_URL}) ${COMMIT2_TITLE} - ${COMMIT2_AUTHOR}" >> $GITHUB_OUTPUT
          fi
          echo "num_commits=$NUM_COMMITS" >> $GITHUB_OUTPUT
          
          # Fetch recent runs
          API_URL="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?per_page=1&status=completed"
          RUNS=$(curl -s -f "$API_URL")
          
          # Check for API errors
          if echo "$RUNS" | jq -e '.message? == "Not Found"' >/dev/null; then
            echo "Error: Repo ${REPO_OWNER}/${REPO_NAME} not found."
            exit 1
          fi
          
          RUNS_COUNT=$(echo "$RUNS" | jq '.workflow_runs | length')
          if [ "$RUNS_COUNT" -gt 0 ]; then
            FULL_SHA=$(echo "$RUNS" | jq -r '.workflow_runs[0].head_commit.id')
            COMMIT_INFO=$(curl -s -f "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/commits/${FULL_SHA}")
            COMMIT_MSG_RAW=$(echo "$COMMIT_INFO" | jq -r '.commit.message')
            
            # First line for title
            TITLE_FIRST_LINE=$(echo "$COMMIT_MSG_RAW" | head -n1 | sed 's/"/\\"/g')
            
            # Second line for description
            DESCRIPTION=$(echo "$COMMIT_MSG_RAW" | sed -n '2p' | sed 's/"/\\"/g' || echo "$COMMIT_MSG_RAW" | sed 's/"/\\"/g')
            
            RUN_NAME=$(echo "$RUNS" | jq -r '.workflow_runs[0].name')
            RUN_STATUS=$(echo "$RUNS" | jq -r '.workflow_runs[0].conclusion')
            RUN_STATUS_UPPER=$(echo "$RUN_STATUS" | tr '[:lower:]' '[:upper:]')
            RUN_URL=$(echo "$RUNS" | jq -r '.workflow_runs[0].html_url')
            RUN_ID=$(echo "$RUNS" | jq -r '.workflow_runs[0].id')
            
            # Sanitize for JSON
            TITLE="${TITLE_FIRST_LINE}"
            PR_LIKE="Workflow run completed #${RUN_ID}: ${RUN_NAME} ${RUN_STATUS_UPPER}"
            
            # Set outputs
            echo "pr_like=$PR_LIKE" >> $GITHUB_OUTPUT
            echo "title=$TITLE" >> $GITHUB_OUTPUT
            echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
            echo "run_url=$RUN_URL" >> $GITHUB_OUTPUT
            echo "run_status=$RUN_STATUS_UPPER" >> $GITHUB_OUTPUT
            echo "run_name=$RUN_NAME" >> $GITHUB_OUTPUT
            echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
            echo "New run detected."
          else
            echo "run_id=none" >> $GITHUB_OUTPUT
            echo "No completed runs foundâ€”skipping notify."
          fi

      - name: Send GitHub-Style Messages to Discord
        if: steps.poll.outputs.run_id != 'none'
        env:
          WEBHOOK_URL: ${{ secrets.FEXEMU_WEBHOOK }}
        run: |
          GITHUB_USERNAME="GitHub"
          GITHUB_AVATAR="https://avatars.githubusercontent.com/u/9919?s=48"  # GitHub org avatar
          
          # First message: PR-like for the run
          MSG1_JSON='{
            "username": "'$GITHUB_USERNAME'",
            "avatar_url": "'$GITHUB_AVATAR'",
            "content": "**'${{ steps.poll.outputs.pr_like }}'**\n[${{ steps.poll.outputs.title }}](${{ steps.poll.outputs.run_url }})"
          }'
          curl -H "Content-Type: application/json" -X POST -d "$MSG1_JSON" "$WEBHOOK_URL"
          
          # Second message: Commit summary
          COMMIT_HEADER="[${{ env.REPO_NAME }}-${BRANCH}] ${{ steps.poll.outputs.num_commits }} new commits"
          COMMIT_BODY="${{ steps.poll.outputs.commit1_line }}\n${{ steps.poll.outputs.commit2_line }}"
          if [ "${{ steps.poll.outputs.num_commits }}" -eq 1 ]; then
            COMMIT_BODY="${{ steps.poll.outputs.commit1_line }}"
          fi
          MSG2_JSON='{
            "username": "'$GITHUB_USERNAME'",
            "avatar_url": "'$GITHUB_AVATAR'",
            "content": "'$COMMIT_HEADER'\n'$COMMIT_BODY'"
          }'
          curl -H "Content-Type: application/json" -X POST -d "$MSG2_JSON" "$WEBHOOK_URL"
          
          echo "Messages sent successfully!"
